---
title: "Introduction to FindIT2"
author: 
  - name: Guandong Shang
    affiliation:
    - National Key Laboratory of Plant Molecular Genetics (NKLPMG), CAS Center for Excellence in Molecular Plant Sciences, Institute of Plant Physiology and Ecology (SIPPE), 200032 Shanghai, P. R. China
    - University of Chinese Academy of Sciences, Shanghai 200032, P. R. China
    email: shangguandong@cemps.ac.cn
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
bibliography: FindIT2.bib
package: "`r pkg_ver('FindIT2')`"
vignette: >
  %\VignetteIndexEntry{Introduction to FindIT2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
```


# Basics

## Install `FindIT2`

`FindIT2` is available on [Bioconductor](http://bioconductor.org) repository for packages, you can install it by:

```{r "install", eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
  }

BiocManager::install("FindIT2")

# Check that you have a valid Bioconductor installation
BiocManager::valid()
```

And the development version from [GitHub](https://github.com/shangguandong1996/FindIT2) with:

```{r 'install_dev', eval = FALSE}
BiocManager::install("shangguandong1996/FindIT2")
```

## Citation

## Acknowledgments

## Introduction
```{r "start", message=FALSE}
# load packages
library(FindIT2)
library(TxDb.Athaliana.BioMart.plantsmart28)
library(SummarizedExperiment)

library(dplyr)
library(ggplot2)

# because of the fa I use, I change the seqlevels of Txdb
Txdb <- TxDb.Athaliana.BioMart.plantsmart28
seqlevels(Txdb) <- c(paste0("Chr", 1:5), "M", "C")

all_geneSet <- genes(Txdb)

```


# Multi-peak multi-gene annotation

The below ChIP peak databset is from [@wang_chromatin_2020a]
```{r "prepare data"}
# load the test ChIP peak bed
ChIP_peak_path <- system.file("extdata", "ChIP.bed.gz", package = "FindIT2")
ChIP_peak_GR <- loadPeakFile(ChIP_peak_path)

ChIP_peak_GR
```

## annotate peak using nearest mode

```{r "mm_nearestgene"}
mmAnno_nearestgene <- mm_nearestGene(peak_GR = ChIP_peak_GR,
                                     Txdb = Txdb)

mmAnno_nearestgene

```


```{r}
plot_annoDistance(mmAnno = mmAnno_nearestgene)
```



```{r}
getAssocPairNumber(mmAnno_nearestgene)

getAssocPairNumber(mmAnno_nearestgene, output_type = "feature_id")
```

```{r}
plot_peakGeneAlias_summary(mmAnno_nearestgene)
plot_peakGeneAlias_summary(mmAnno_nearestgene, output_type = "feature_id")
```

## find realted peak using gene Bound mode

```{r "mm_geneBound"}
genes_Chr5 <- names(all_geneSet[seqnames(all_geneSet) == "Chr5"])
genes_Chr5_notAnno <- genes_Chr5[!genes_Chr5 %in% unique(mmAnno_nearestgene$gene_id)]
genes_Chr5_Anno <- unique(mmAnno_nearestgene$gene_id)

mmAnno_geneBound <- mm_geneBound(peak_GR = ChIP_peak_GR,
                                 Txdb = Txdb,
                                 input_genes = c(genes_Chr5_Anno[1:5], genes_Chr5_notAnno[1:5]))

mmAnno_geneBound

```

## find related peak using gene scan mode

```{r "mm_geneScan"} 
mmAnno_geneScan <- mm_geneScan(peak_GR = ChIP_peak_GR,
                               Txdb = Txdb,
                               upstream = 2e4,
                               downstream = 2e4)

mmAnno_geneScan

```

```{r}
getAssocPairNumber(mmAnno_geneScan)

getAssocPairNumber(mmAnno_geneScan, output_type = "feature_id")
```

```{r}
plot_peakGeneAlias_summary(mmAnno_geneScan)
plot_peakGeneAlias_summary(mmAnno_geneScan, output_type = "feature_id")
```

# Calculate regulation potential(RP)

## calculate RP using mmAnno

```{r "calcRP_TFHit"}
# if you just want to get RP_df, you can set report_fullInfo FALSE
fullRP_hit <- calcRP_TFHit(mmAnno = mmAnno_geneScan,
                           Txdb = Txdb,
                           report_fullInfo = TRUE)

peakRP_gene <- metadata(fullRP_hit)$peakRP_gene
peakRP_gene

```



## Calculate RP using bw file
```{r "calcRP_bw"}

bwFile <- system.file("extdata", "E50h_sampleChr5.bw", package = "FindIT2")
RP_df <- calcRP_coverage(bwFile = bwFile,
                         Txdb = Txdb,
                         Chrs_included = "Chr5")

head(RP_df)

```

## Calculate RP using mmAnno result and peakScore matrix
```{r "calcRP_region"}
data("ATAC_normCount")

ATAC_peak_path <- system.file("extdata", "ATAC.bed.gz", package = "FindIT2")
ATAC_peak_GR <- loadPeakFile(ATAC_peak_path)

mmAnno_regionRP <- mm_geneScan(ATAC_peak_GR,
                               Txdb,
                               upstream = 2e4,
                               downstream = 2e4)

calcRP_region(mmAnno = mmAnno_regionRP,
              peakScoreMt = ATAC_normCount,
              Txdb = Txdb,
              Chrs_included = "Chr5") -> regionRP

sumRP <- assays(regionRP)$sumRP
head(sumRP)

fullRP <- assays(regionRP)$fullRP
head(fullRP)

```

# Find influential target

```{r "findITarget"}
data("RNADiff_LEC2_GR")
integrate_ChIP_RNA(result_geneRP = peakRP_gene,
                   result_geneDiff = RNADiff_LEC2_GR) -> merge_result

merge_result

# if you want to extract merge target data
target_result <- merge_result$data
target_result

```

# Find influential TF(IT)

```{r "prepare_for_findIT"}

input_genes <- target_result$gene_id[1:50]

related_peaks <- mm_geneBound(peak_GR = ATAC_peak_GR,
                              Txdb = Txdb,
                              input_genes = input_genes)
input_feature_id <- related_peaks$feature_id

# AT1G28300 is LEC2 tair ID
ChIP_peak_GR$TF_id <- "AT1G28300"
```


## Find IT of input peak based on shuffle

```{r "findIT_enrichInShuffle"}
set.seed(20160806)
findIT_enrichInShuffle(input_feature_id = input_feature_id,
                       peak_GR = ATAC_peak_GR,
                       TF_GR_database = ChIP_peak_GR,
                       shuffleN = 10) -> result_enrichInShuffle
result_enrichInShuffle

```

## Find IT of input peak based on fisher test

```{r "findIT_enrichInAll"}
findIT_enrichInAll(input_feature_id = input_feature_id, 
                   peak_GR = ATAC_peak_GR, 
                   TF_GR_database = ChIP_peak_GR) -> result_enrichInAll

result_enrichInAll

```

you can parse your result_result_enrichInAll

```{r}
jaccard_findIT_enrichInAll(input_feature_id = input_feature_id,
                           peak_GR = ATAC_peak_GR,
                           TF_GR_database = ChIP_peak_GR,
                           input_TF_id = "AT1G28300") -> enrichAll_jaccard

# it report the jaccard similarity of TF you input

# but here I make the TF's own jaccard similarity 0, which is useful for heatmap
# If you want to convert it to 1, you can just use 
# diag(enrichAll_jaccard) <- 1

# it only report the one TF jaccard similarity matrix, which may confuse you
# you can see the several TF in next section
enrichAll_jaccard

```


## Find IT of input genes based on fisher test

```{r "findIT_TTPair"}
data("TF_target_database")

result_TTpair <- findIT_TTPair(input_genes = input_genes,
                               TF_target_database = TF_target_database,
                               gene_background = names(all_geneSet))

result_TTpair

```

you can parse your result_TT pair

```{r}

# Here I use the all TF_id because I just have three TF in result_TTpair
# For you, you can select top N TF_id as input_TF_id
jaccard_findIT_TTpair(input_genes = input_genes,
                      TF_target_database = TF_target_database,
                      input_TF_id = result_TTpair$TF_id) -> TTpair_jaccard

# Here I make the TF's own jaccard similarity 0, which is useful for heatmap
# If you want to convert it to 1, you can just use 
# diag(TTpair_jaccard) <- 1
TTpair_jaccard

```


## Find IT of input genes based on TF hit

```{r "findIT_TFHit"}

set.seed(20160806)
result_TFHit <- findIT_TFHit(input_genes = input_genes,
                             Txdb = Txdb,
                             TF_GR_database = ChIP_peak_GR,
                             scan_dist = 2e4,
                             decay_dist = 1e3,
                             Chrs_included = "Chr5",
                             background_number = 3000)

result_TFHit

```

## Find IT of input genes based on region RP

```{r}

set.seed(20160806)
result_findIT_regionRP <- findIT_regionRP(regionRP = regionRP,
                                          Txdb = Txdb,
                                          TF_GR_database = ChIP_peak_GR,
                                          input_genes = input_genes,
                                          background_number = 3000)

TF_percentMean <- assays(result_findIT_regionRP)$TF_percentMean
TF_pvalue <- assays(result_findIT_regionRP)$TF_pvalue

```

尽管其p-value由于，你输入的是所有样本综合的peak，然后基因组比较小，使得你的每个输入基因只有一个比较重要的peak，那么这个peak不管变化有多大，percent都不会变。同时，你需要知道p-value的真正含义。但是其真正的长处在于其折叠与扩展性。取决于你的目的，你可以建立多种类型的矩阵

- 行为TF，列为时间点/样本，数值为percentMean
- 在单个时间点/样本里面，行为基因，列是TF，数值为percent
- 挑选某个TF，行为基因，列为时间点/样本，数值为percent

分别的提取代码为：

`行为TF，列为时间点/样本，数值为percentMean`
```{r}
TF_percentMean
```

`在单个时间点/样本里面，行为基因，列是TF，数值为percent`
```{r}
metadata(result_findIT_regionRP)$percent_df %>% 
    filter(sample == "E5_0h_R1") %>% 
    select(gene_id, percent, TF_id) %>% 
    tidyr::pivot_wider(values_from = percent, names_from = gene_id) -> E50h_TF_percent

E50h_TF_mt <- as.matrix(E50h_TF_percent[, -1])
rownames(E50h_TF_mt) <- E50h_TF_percent$TF_id

# because here I just have one TF, so the matrix do not look good :)
E50h_TF_mt

```

`挑选某个TF，行为基因，列为时间点/样本，数值为percent`
```{r}
metadata(result_findIT_regionRP)

metadata(result_findIT_regionRP)$percent_df %>% 
  filter(TF_id == "AT1G28300") %>% 
  select(-TF_id) %>% 
  tidyr::pivot_wider(names_from = sample, values_from = percent) -> LEC2_percent_df

LEC2_percent_mt <- as.matrix(LEC2_percent_df[, -1])
rownames(LEC2_percent_mt) <- LEC2_percent_df$gene_id

heatmap(LEC2_percent_mt, Colv = NA, scale = "none")
  
```

parse result using

```{r, eval = FALSE}
merge_result <- c(regionRP, result_findIT_regionRP)
shinyParse_findIT_regionRP(merge_result = merge_result, mode = "gene")

shinyParse_findIT_regionRP(merge_result = merge_result,mode = "TF")
```

## Find IT of input genes based on motif activity response

```{r}
# Because here I just use the one TF, which does not does not meet the conditions of ridge regression.
# So the output here just the correlation value !!!, not the z-scale value
# But if you input more than one TF, it will use the ridge regression, and convert the coef of each TF into z-scale value 
# This MARA is similar with 
# https://gimmemotifs.readthedocs.io/en/master/tutorials.html#find-differential-motifs
findIT_MARA(input_feature_id = input_feature_id,
            peak_GR = ATAC_peak_GR,
            peakScoreMt = ATAC_normCount,
            TF_GR_database = ChIP_peak_GR,
            log = TRUE,
            meanScale = TRUE) -> result_findIT_MARA

result_findIT_MARA
```

```{r}
# when you get the zscale value from findIT_MARA, you can use integrate_replicates to integrate replicate zscale by setting type as "rank_zscore"
# Here each replicate are combined using Stouffer’s method
ATAC_colData <- data.frame(row.names = colnames(ATAC_normCount),
                           type = gsub("_R[0-9]", "", colnames(ATAC_normCount))
                           )
findIT_MARA_mt <- as.matrix(result_findIT_MARA[, -1])
rownames(findIT_MARA_mt) <- result_findIT_MARA$TF_id

integrate_replicates(mt = findIT_MARA_mt,
                     colData = ATAC_colData,
                     type = "rank_zscore")

```

## integrate result

```{r}
list(TF_Hit = result_TFHit,
     enrichAll = result_enrichInAll,
     enrichShuffle = result_enrichInShuffle,
     TT_pair = result_TTpair
     ) -> rank_merge_list
purrr::map(names(rank_merge_list), .f = function(x){
    data <- rank_merge_list[[x]]
    data %>% 
        select(TF_id, rank) %>% 
        mutate(source = x) -> data
    return(data)
}) %>% 
    do.call(rbind, .) %>% 
    tidyr::pivot_wider(names_from = source, values_from = rank) -> rank_merge_df

rank_merge_df

# we only select TF which appears in all source
rank_merge_df <- rank_merge_df[rowSums(is.na(rank_merge_df)) == 0, ]

rank_merge_mt <- as.matrix(rank_merge_df[, -1])

colData <- data.frame(row.names = colnames(rank_merge_mt),
                      type = rep("source", ncol(rank_merge_mt)))

integrate_replicates(mt = rank_merge_mt, colData = colData, type = "rank")

```


# Calculate feature correlation

## Calculate peak gene correlation

```{r}
data("RNA_normCount")

peak_GR <- loadPeakFile(ATAC_peak_path)[1:100]
mmAnno <- mm_geneScan(peak_GR,Txdb)

ATAC_colData <- data.frame(row.names = colnames(ATAC_normCount),
                           type = gsub("_R[0-9]", "", colnames(ATAC_normCount))
                           )

integrate_replicates(ATAC_normCount, ATAC_colData) -> ATAC_normCount_merge
RNA_colData <- data.frame(row.names = colnames(RNA_normCount),
                          type = gsub("_R[0-9]", "", colnames(RNA_normCount))
                          )
integrate_replicates(RNA_normCount, RNA_colData) -> RNA_normCount_merge

peakGeneCor(mmAnno = mmAnno,
            peakScoreMt = ATAC_normCount_merge,
            geneScoreMt = RNA_normCount_merge,
            parallel = FALSE) -> mmAnnoCor

```

```{r}
subset(mmAnnoCor, cor > 0.8) %>% 
  getAssocPairNumber()
```


```{r}
plot_peakGeneCor(mmAnnoCor = mmAnnoCor,
                 select_gene = "AT5G01075")

plot_peakGeneCor(mmAnnoCor = subset(mmAnnoCor, cor > 0.95),
                 select_gene = "AT5G01075")

plot_peakGeneCor(mmAnnoCor = subset(mmAnnoCor, cor > 0.95),
                 select_gene = "AT5G01075") +
  geom_point(aes(color = time_point))

plot_peakGeneAlias_summary(mmAnno = mmAnnoCor,
                           mmAnno_corFilter = subset(mmAnnoCor, cor > 0.8))

```

```{r eval=FALSE}
shinyParse_peakGeneCor(mmAnnoCor)
```


## Calculate enhancer promoter correlation

```{r}
enhancerPromoterCor(peak_GR = peak_GR[1:100],
                    Txdb = Txdb,
                    peakScoreMt = ATAC_normCount,
                    up_scanPromoter = 500,
                    down_scanPromoter = 500,
                    up_scanEnhancer = 2000,
                    down_scanEnhacner = 2000,
                    parallel = FALSE) -> mmAnnoCor_linkEP
```

```{r}
plot_peakGeneCor(mmAnnoCor = mmAnnoCor_linkEP,
                 select_gene = "AT5G01075") -> p

p

p$data$type <- gsub("_R[0-9]", "", p$data$time_point)
p$data$type <- factor(p$data$type, levels = unique(p$data$type))

p +
    ggplot2::geom_point(aes(color = type))

```

```{r}
# please pay attention that the number below should add 1
# because I do not include nearest promoter into the result of enhancerPromoterCor
plot_peakGeneAlias_summary(mmAnno = mmAnnoCor_linkEP,
                           mmAnno_corFilter = subset(mmAnnoCor_linkEP, cor > 0.8))
```

```{r eval=FALSE}
shinyParse_peakGeneCor(mmAnnoCor_linkEP)
```

# Session info

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```

# References


